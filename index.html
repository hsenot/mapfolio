<!DOCTYPE html>
<html>
<head>
	<title>SolarSize - Drawing solar panels</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
	<link rel="stylesheet" href="leaflet/leaflet.css" />
	<link rel="stylesheet" href="leaflet.draw/leaflet.draw.css" />
	<!--[if lte IE 8]>
		<link rel="stylesheet" href="leaflet.ie.css" />
		<link rel="stylesheet" href="leaflet.draw/leaflet.draw.ie.css" />
	<![endif]-->
	<style>
		/* Base HTML */
		body {
			margin:10px;
		}
		form {
			margin: 10px;
		}
		input[type="text"] {
			font-size:12px;
		}

		/* Bootstrap */
		.well {
			border-radius: 8px 8px 8px 8px;
			padding: 8px;
			margin-bottom: 8px;
		}
		.spanmap {
 		   width: 610px;
		}
		.row {
		    margin-left: 0px;
		}
		[class*="span"] {
			margin-right: 10px;
			margin-left: 0;
		}

		/* Leaflet */		
		.leaflet-container .leaflet-control-attribution {
			font-size: 8px;
		}

		/* Misc */
		.centered {
			text-align: center;
		}

	</style>
</head>
<body>
	<div class="row">
		<div class="spanmap">
			<div class="row">
				<div class="well" style="width:140px;">
					<p style="display:inline-block;font-size:12px;line-height:15px;text-align:center;">Total building area identified within the map:</p> <p id="total_roof_area" style="font-size:15px;text-align:center">calculating ...</p>
				</div>
			</div>
		</div>
	</div>

	<div class="row">
		<div class="spanmap">
			<div class="well" style="width: 592px;">
				<div id="map" style="width: 592px; height: 592px; border: 1px;"></div>
			</div>
		</div>
	</div>

    <script src="http://code.jquery.com/jquery.js"></script>
    <script src="bootstrap/js/bootstrap.min.js"></script>
	<script src="leaflet/leaflet.js"></script>
	<script src="leaflet-plugins/layer/tile/Bing.js"></script>
	<script src="leaflet.draw/leaflet.draw.js"></script>
	<script>

		var map, refreshBuildings, buildingVectorLayer, totalRoofAreaDisplayed = 0, zoomToBuilding, drawnItems;
		// Removed: 'black'
		var css_colors = ['aqua', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow'];
		function numberWithCommas(x) {
		    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
		}

		function initmap() {
			// Set up the map
			map = L.map('map').setView([-37.815,144.963], 16).on('removelayer',function(f){
				alert("removing layer"+f);
			});
			// Create the Bing layer and add it to the map
			var binglayer = new L.BingLayer('AgxcV_eHKN9sD_UzjdBKiXru-b_mGfIKjD1SkgR0zJhhGQAAKqFvTs442gc1Eaay','Aerial')
				.addTo(map);

			buildingVectorLayer = L.geoJson({features:[],type:"FeatureCollection"},{
			    style: function (feature) {
			    	var fcolor = 'red';
			    	if (feature.properties.lga)
			    	{
			    		fcolor = css_colors[parseInt(feature.properties.lga) % css_colors.length];
			    	}
			        return {
			        	color: fcolor,
			        	weight: 3,
			        	opacity: 0.3
			    	};
			    },
			    onEachFeature: function (feature, layer) {
			    	var feature_name = feature.properties.name;
			    	totalRoofAreaDisplayed = totalRoofAreaDisplayed + parseInt(feature.properties.area_m2);
			    	if (!feature_name)
			    	{
			    		feature_name = "Unknown";
			    	}
			    	var htmlArray = [];
			    	htmlArray.push("<b>"+feature_name+"</b>");
			    	htmlArray.push("<br>Approx area: "+numberWithCommas(feature.properties.area_m2)+" m<sup>2</sup>");
			    	htmlArray.push("Zoom to <a href='#"+feature.properties.id+"' onClick='zoomToBuilding("+feature.properties.id+")'>this building</a>");
			        layer.bindPopup(htmlArray.join("<br>"),{keepInView:true});
			    }
			}).addTo(map);

			drawnItems = new L.FeatureGroup();
			map.addLayer(drawnItems);

			var drawControl = new L.Control.Draw({
				draw: {
					// Other positions just don't work
					position: 'topleft',
					polyline:false,
					rectangle:false,
					circle:false,
					marker:false,
					polygon: {
						title: 'Draw a building',
						allowIntersection: false,
						drawError: {
							color: '#b00b00',
							timeout: 1000
						},
						shapeOptions: {
							color: '#bada55'
						},
						showArea: false
					}
				},
				edit: {
					featureGroup: drawnItems,
					edit: false
				}
			});

			// Tooltip overrides before the control is added to the map
			L.drawLocal.draw.toolbar.buttons.polygon = "Draw a building roof";
			L.drawLocal.edit.toolbar.buttons.remove = "Delete a building roof";

			map.addControl(drawControl);

			map.on('draw:created', function (e) {
				var type = e.layerType,
					layer = e.layer;

				if (type === 'polygon') {
					layer.bindPopup('A popup!');
				}

				// Here, we probably need to insert it into the database
				// Same table or different table? Same table might be easier for the app but will need special management when refreshing the OSM buildings and backups
				// To avoid disaster of drawn data being wiped out, we probably will need a separate table

				drawnItems.addLayer(layer);

				// Move to the center of the new building: this will trigger the layer redraw and we don't need to keep the temporary drawn structure on the map!
			});

			refreshBuildings = function(){
				// Loading indicator
				$('#total_roof_area').html("calculating ...");
				// fetching the new features based on the new 
				$.ajax({
					type : 'GET',
					dataType : 'json',
					data: {
						geotable:'building',
						geomfield:'the_geom',
						fields:'id,name,round(ST_Area(ST_Transform(the_geom,3111))::numeric,0) as area_m2,(select l.lga_code from lga l where ST_Intersects(ST_Centroid(the_geom),l.geom)) as lga',
						limit: 200,
						orderby:'ST_Distance(the_geom,ST_SetSRID(ST_Point('+map.getCenter().lng+','+map.getCenter().lat+'),4326))',
						sort:'ASC'
					},
					url: 'ws/postgis_geojson.php?bbox=' + map.getBounds().toBBoxString(),
					success : function(data) {
						// object made of id
						var new_ids = {};
						for (f in data.features){
							if (data.features.hasOwnProperty(f)) {
								new_ids[data.features[f].properties.id]=true;
							}	
						}
						// Remove existing features from the layer
						if (buildingVectorLayer)
						{
							//map.removeLayer(buildingVectorLayer);
							for (f in buildingVectorLayer._layers)
							{
								var current_feature = buildingVectorLayer._layers[f];
								if (current_feature.feature.properties.id in new_ids)
								{
									new_ids[current_feature.feature.properties.id]=false;
								}
								else
								{
									// Updating roof area by substracting the areas of features we remove
									totalRoofAreaDisplayed = totalRoofAreaDisplayed - parseInt(current_feature.feature.properties.area_m2);
									// Deleting only this feature - clearLayers would remove all features
									buildingVectorLayer.removeLayer(buildingVectorLayer._layers[f]);
								}
							}
						}

						// Only getting the features from data where new_ids is true
						var data_trimmed = {features:[],type:"FeatureCollection"};
						for (f in data.features)
						{
							if (data.features.hasOwnProperty(f)) {
								if (new_ids[data.features[f].properties.id])
								{
									data_trimmed.features.push(data.features[f]);
								}
							}
						}

						// Adding the new features
						buildingVectorLayer.addData(data_trimmed);

						// Refresh the total roof area displayed
						$('#total_roof_area').html(numberWithCommas(totalRoofAreaDisplayed)+" m<sup>2</sup>");
					} 
				});				
			}

		}

		initmap();
		map.on('moveend',refreshBuildings)
		refreshBuildings();

		zoomToBuilding = function(buildingId){ 
			// Assumption is that the building exists in the current vector layer
			for (f in buildingVectorLayer._layers)
			{
				if (buildingVectorLayer._layers[f].feature.properties.id==buildingId)
				{
					buildingVectorLayer._layers[f].closePopup();
					map.fitBounds(buildingVectorLayer._layers[f].getBounds());
					break;
				}
			}
		}

	</script>
</body>
</html>
